# -*- coding: utf-8 -*-
"""No2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vI0yJS1rQa8G0Tr4lQ2T7P3Uixu8fEeh
"""

import matplotlib.pyplot as plt

# Function to perform Euler Method
def euler_method(x, y, dx, p0, p2, p6):
    results = [(x[0], y[0])]
    for i in range(1, len(x)):
        h = dx
        x_end = x[i-1] + h
        if x_end > x[i]:
            x_end = x[i]

        y_value = y[i-1]
        current_x = x[i-1]

        while current_x < x_end:
            y_value = y_value + h * (p0 * y_value + p2 * y_value**2 + p6 * y_value**6)
            current_x = current_x + h
            results.append((current_x, y_value))

    return results

x = [0.0, 0.2, 0.4]
y = [0.00000, 0.74140, 1.3718]

print("Input values:")
for xi, yi in zip(x, y):
    print(f"x: {xi}, y: {yi}")

p0_coefficient = 1.0
p2_coefficient = 1.0
p6_coefficient = 1.0
results = euler_method(x, y, dx=0.1, p0=p0_coefficient, p2=p2_coefficient, p6=p6_coefficient)
x_results, y_results = zip(*results)

print("Euler method results:")
for xi, yi in zip(x_results, y_results):
    print(f"x: {xi}, y: {yi}")

plt.figure(figsize=(8, 6))
plt.plot(x_results, y_results, marker='o', linestyle='-', color='r')
plt.title("Euler Method")
plt.xlabel("x")
plt.ylabel("y")
plt.grid(True)
plt.show()

# Function to perform Heun's Method for numerical differentiation
def heuns_method(x, y):
    h = x[1] - x[0]
    dy_dx = []


    for i in range(len(x) - 1):
        y_predictor = y[i] + h * numerical_derivative(y[i], x[i])
        y_corrector = y[i] + (h / 2) * (numerical_derivative(y[i], x[i]) + numerical_derivative(y_predictor, x[i+1]))

        dy_dx.append((y_corrector - y[i]) / h)

    return dy_dx

def numerical_derivative(y, x):
    return (y**2) / x

x_data = [1.1, 1.2, 1.3, 1.4]
y_data = [9.025013, 11.02318, 13.46374, 16.44465]

print("Input values:")
for xi, yi in zip(x_data, y_data):
    print(f"x: {xi}, y: {yi}")
dy_dx_result = heuns_method(x_data, y_data)

print("Heun's Method results:")
for dy_dx_val in dy_dx_result:
    print(f"dy_dx: {dy_dx_val}")

plt.figure(figsize=(8, 6))
plt.plot(x_data[:-1], dy_dx_result, marker='o', linestyle='-', color='b')
plt.title("Heun's Method for Numerical Differentiation")
plt.xlabel("x")
plt.ylabel("dy/dx")
plt.grid(True)
plt.show()

#driver & adaptive runge-kutta method
import matplotlib.pyplot as plt

def f(x, y):
    return y

def runge_kutta_order_4(x, y, h):
    k1 = h * f(x, y)
    k2 = h * f(x + h/2, y + k1/2)
    k3 = h * f(x + h/2, y + k2/2)
    k4 = h * f(x + h, y + k3)

    return y + (k1 + 2*k2 + 2*k3 + k4) / 6

def driver_method(x_start, x_end, y_start, h_initial, tolerance):
    x = x_start
    y = y_start
    h = h_initial

    results = [(x, y)]

    while x < x_end:
        while True:
            y1 = runge_kutta_order_4(x, y, h)
            y2_step1 = runge_kutta_order_4(x, y, h/2)
            y2_step2 = runge_kutta_order_4(x + h/2, y2_step1, h/2)
            error = abs(y2_step2 - y1)

            if error < tolerance:
                break

            h = h / 2

        h = min(2 * h, x_end - x)

        x = x + h
        y = y1

        results.append((x, y))

    return results

x_start = 0.0
x_end = 1.0
y_start = 1.0
h_initial = 0.1
tolerance = 1e-5

results = driver_method(x_start, x_end, y_start, h_initial, tolerance)

for x, y in results:
    print(f"x: {x}, y: {y}")

x_values = [result[0] for result in results]
y_values = [result[1] for result in results]

plt.plot(x_values, y_values, marker='o', linestyle='-')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Numerical Integration using Adaptive Fourth-Order Runge-Kutta Method')
plt.grid(True)
plt.show()

# Fungsi yang akan diintegrasikan
def f(x, y):
    return y  # Ganti dengan fungsi yang sesuai

# Metode Runge-Kutta Orde-4
def runge_kutta_order_4(x, y, h):
    k1 = h * f(x, y)
    k2 = h * f(x + h/2, y + k1/2)
    k3 = h * f(x + h/2, y + k2/2)
    k4 = h * f(x + h, y + k3)

    return y + (k1 + 2*k2 + 2*k3 + k4) / 6

# Metode Driver menggunakan metode Runge-Kutta adaptif
def driver_method(x_start, x_end, y_start, h_initial, tolerance):
    x = x_start
    y = y_start
    h = h_initial

    results = [(x, y)]

    while x < x_end:
        # Iterasi metode adaptif Runge-Kutta hingga mendapatkan error yang kecil
        while True:
            y1 = runge_kutta_order_4(x, y, h)
            y2_step1 = runge_kutta_order_4(x, y, h/2)
            y2_step2 = runge_kutta_order_4(x + h/2, y2_step1, h/2)
            error = abs(y2_step2 - y1)

            # Jika error kecil, kita lanjut ke iterasi berikutnya
            if error < tolerance:
                break

            # Jika error besar, kita perkecil nilai h
            h = h / 2

        # Pilih nilai h yang baru untuk iterasi berikutnya
        h = min(2 * h, x_end - x)

        # Update nilai x dan y
        x = x + h
        y = y1

        results.append((x, y))

    return results

# Contoh penggunaan
x_start = 0.0
x_end = 1.0
y_start = 1.0
h_initial = 0.1
tolerance = 1e-5

results = driver_method(x_start, x_end, y_start, h_initial, tolerance)

# Tampilkan hasil
for x, y in results:
    print(f"x: {x}, y: {y}")

plt.plot(x_data[:-1], dy_dx_result, marker='o', linestyle='-')
plt.xlabel('x')
plt.ylabel('dy/dx')
plt.title('Numerical Differentiation using Fourth-Order Runge-Kutta Method')
plt.grid(True)
plt.show()